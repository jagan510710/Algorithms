
public class Node<T> {
    var value: T
    var next: Node<T>?
    
    init(value: T) {
        self.value = value
    }
}



class SingleLinkedList<T>   {
    
    var head: Node<T>? 
    
   
    
    public func append(value: T) {
        let newNode = Node(value: value)
        if var h = head {
            while h.next != nil {
                h = h.next!
            }
            h.next = newNode
            
        } else {
            head = newNode
        }
    }
   




    func deleteNode(position: Int)
    {
        if head == nil{
        return
        }
        var temp = head
        
        if (position == 0)
        {
            head = temp?.next
            return
        }
    
        for _ in 0..<position-1 where temp != nil {
            temp = temp?.next
        }

        if temp == nil || temp?.next == nil{
           return
        }

        let nextToNextNode = temp?.next?.next
        
        temp?.next = nextToNextNode
    }
    
    }
    
    

extension SingleLinkedList : CustomStringConvertible {
    var description: String {
       
    var text = ""
    var node = head
    while node != nil {
      text += "\(node!.value)"
      node = node!.next
      if node != nil { text += "-> " }
    }
    return text
    }
}
let ll = SingleLinkedList<Int>()
ll.append(value: 1)
ll.append(value: 2)
ll.append(value: 4)
ll.append(value: 9)
print(ll.description)
ll.deleteNode(position:2)
print(ll.description)



//////////////////////////////////////////////////////////////////////////////////////////








public class Node {
    public let value: Int
    var next: Node? = nil
    var previous: Node? = nil
    public init(_ value: Int) {
        self.value = value
    }
}
extension Node: Equatable  {
    public static func ==(lhs: Node, rhs: Node) -> Bool {
        return lhs.value == rhs.value
    }
}
extension Node: CustomStringConvertible {
    public var description: String {
        get {
            return "Node(\(value))"
        }
    }
}


 public class LinkedList {
   var head: Node?
   private var tail: Node?

  public var isEmpty: Bool {
    return head == nil
  }

  //first
  public var first: Node? {
    return head
  }

  //last
  public var last: Node? {
    return tail
  }
//   //Append node to LinkedList
  public func append(_ value: Int) {
    let newNode = Node(value)
    if let tailNode = tail {
      newNode.previous = tailNode
      tailNode.next = newNode
    } else {
      head = newNode
    }
    tail = newNode
  }
 
  //Find Node at Index
  public func nodeAt(_ index: Int) -> Node? {
    if index >= 0 {
      var node = head
      var i = index
      while node != nil {
        if i == 0 { return node }
        i -= 1
        node = node!.next
      }
    }
    return nil
  }
    

  //remove Node
  public func remove(_ node: Node) -> Int {
    let previousNode = node.previous
    let nextNode = node.next

    if let prev = previousNode {
      prev.next = nextNode
    } else {
      head = nextNode
    }
    nextNode?.previous = previousNode

    if nextNode == nil {
      tail = previousNode
    }

    node.previous = nil
    node.next = nil
    
    return node.value
  }
    
    var count: Int {
        if (head?.value == nil) {
            return 0
        }
        else {
            var current: Node? = head
            var x: Int = 1
            
            //cycle through the list of items
            while ((current?.next) != nil) {
                current = current?.next!
                x = x + 1
            }
            return x
        }
    }
 
//     //remove from index
    func remove(at index: Int) {
        var toDeleteNode = nodeAt(index)
        guard toDeleteNode != nil else {
            print("Index out of bounds.")
            return
        }
        
        let previousNode = toDeleteNode?.previous
        let nextNode = toDeleteNode?.next
        
        if previousNode == nil {
            head = nextNode
        }
        
        if toDeleteNode?.next == nil {
            tail = previousNode
        }
        
        previousNode?.next = nextNode
        nextNode?.previous = previousNode
        
        toDeleteNode = nil
    }

 }

public struct LinkedListIterator: IteratorProtocol {
    public typealias Element = Node

    /// The current node in the iteration
    private var currentNode: Element?

    fileprivate init(startNode: Element?) {
        currentNode = startNode
    }

    public mutating func next() -> LinkedListIterator.Element? {
        let node = currentNode
        currentNode = currentNode?.next

        return node
    }
}

extension LinkedList: Sequence {
    public typealias Iterator = LinkedListIterator

    public func makeIterator() -> LinkedList.Iterator {
        return LinkedListIterator(startNode: first)
    }
}

extension LinkedList : CustomStringConvertible 
{
   public var description: String {
       
    var text = ""
     for node in self
     {
       text += "\(node.value)"
       if node.next != nil
       {
        text += "-> "
       }
     }
    return text
    }
}
     
  let newNode = Node.init(-1)

let ll = LinkedList()
ll.append(0)
ll.append(9)
ll.append(1)
ll.append(2)
ll.append(4)

print(ll.description)
let ll1 = LinkedList()
ll1.append(3)
ll1.append(2)
ll1.append(4)

print(ll1.description)
print(ll1.count)
// from tail check matching
  var c1 = ll.last
  var c2 = ll1.last

  while c1 != nil && c2 != nil
  {
    if c1 != c2
    {
      if let value  = c1?.next?.value
      {
       print( "Reference of the node with intersect value = \(value)")
      }
      else
      {
        print("No intersect")
      }
        break
    }
    c1 = c1?.previous
    c2 = c2?.previous
  }








