///// With Generics//////////



extension StringProtocol  {
    var digits: [Int] { return compactMap{ $0.wholeNumberValue } }
}
extension LosslessStringConvertible {
    var string: String { return .init(self) }
}
extension Numeric where Self: LosslessStringConvertible {
    var digits: [Int] {return  string.digits }
}
extension Character:Palindrome
{

}
extension Int:Palindrome
{

}
protocol Palindrome:Comparable
{

}

extension Array where Element : Palindrome
{
  func isPalindrome()->Bool
  {
    if count > 1
    {
      return  palindrome(self,left:0,right:count-1)
    }
    return false
  }
  func palindrome<T:Palindrome>(_ arr:[T],left:Int,right:Int)->Bool
  {
    if left>right{return true}
    if arr[left] != arr[right]
    {
     // print(arr[left])
      return false
    }
    return palindrome(arr,left:left+1,right:right-1)
  }
}
let string = "MAtDAM"
let digits = Array(string)
print(digits)
print(digits.isPalindrome().description)

let number = "1234321"
print(number.digits)
print(number.digits.isPalindrome().description)


["M", "A", "t", "D", "A", "M"]
false
[1, 2, 3, 4, 3, 2, 1]
true



//////////////

extension String {
  var lowerCaseRemovedSpace: String {
        return self.filter { $0 != " " }.lowercased()
    }
    var removeSpecialCharsFromString:String {
         let chars = Set("abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLKMNOPQRSTUVWXYZ1234567890")
    return String(self.filter { chars.contains($0) })
}
    var isPal: Bool {
        return  self.lowerCaseRemovedSpace.removeSpecialCharsFromString == String(self.reversed()).lowerCaseRemovedSpace.removeSpecialCharsFromString
    }
    var uniCharactersArr:Array<Character>
     {
       return Set(self).sorted()
     }
}




protocol GenericProtocol {
func isPalindrome(_ word: String) -> (Bool,Array<Character>)
}
extension GenericProtocol
{

func isPalindrome(_ word: String) -> (Bool,Array<Character>) {
    let word = word.lowerCaseRemovedSpace.removeSpecialCharsFromString
    let charArr = Array(word)
    for index in 0..<charArr.count/2
    {
      if charArr[index] != charArr[charArr.count-1-index]
      {
        return(false,word.uniCharactersArr)
      }
    }
    // for (i, character) in word.enumerated() {
    //     if character != Array(word)[word.count-i-1] {
    //         // uniCharacters.append(character)
    //                return (false,"")

    //     }
    // }

  // }
  
    return (true,word.uniCharactersArr)
}

}


extension String : GenericProtocol
{
    func palindromeResult()->(Bool,Array<Character>)
    {
      return isPalindrome(self) 
    }
}

extension Int:GenericProtocol
{
 
   func palindromeResult()->(Bool,Array<Character>)
    {
      return isPalindrome(String(self))
    }
    

}


var palDict = [String:Int]()
let arrWords = ["madam","we","civic","madam","ert","yes"]
arrWords.forEach{(word) in
    if word.palindromeResult().0 == true{
          let count = palDict[word] ?? 0
           palDict[word] = count + 1
    }
}


print(("Was it a car or a cat I saw").palindromeResult().1)
print(("Was it a car or a cat I saw").palindromeResult().0.description)
print(12445321.palindromeResult().1)
print(12445321.palindromeResult().0.description)
print(palDict)


OutPut:

["a", "c", "i", "o", "r", "s", "t", "w"]
true
["1", "2", "3", "4", "5"]
false
["civic": 1, "madam": 2]
