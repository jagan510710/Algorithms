

extension String {
  var lowerCaseRemovedSpace: String {
        return self.filter { $0 != " " }.lowercased()
    }
    var removeSpecialCharsFromString:String {
         let chars = Set("abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLKMNOPQRSTUVWXYZ1234567890")
    return String(self.filter { chars.contains($0) })
}
    var isPal: Bool {
        return  self.lowerCaseRemovedSpace.removeSpecialCharsFromString == String(self.reversed()).lowerCaseRemovedSpace.removeSpecialCharsFromString
    }
    var uniCharactersArr:Array<Character>
     {
       return Set(self).sorted()
     }
}




protocol GenericProtocol {
func isPalindrome(_ word: String) -> (Bool,Array<Character>)
}
extension GenericProtocol
{

func isPalindrome(_ word: String) -> (Bool,Array<Character>) {
    let word = word.lowerCaseRemovedSpace.removeSpecialCharsFromString
    let charArr = Array(word)
    for index in 0..<charArr.count/2
    {
      if charArr[index] != charArr[charArr.count-1-index]
      {
        return(false,word.uniCharactersArr)
      }
    }
    // for (i, character) in word.enumerated() {
    //     if character != Array(word)[word.count-i-1] {
    //         // uniCharacters.append(character)
    //                return (false,"")

    //     }
    // }

  // }
  
    return (true,word.uniCharactersArr)
}

}


extension String : GenericProtocol
{
    func palindromeResult()->(Bool,Array<Character>)
    {
      return isPalindrome(self) 
    }
}

extension Int:GenericProtocol
{
 
   func palindromeResult()->(Bool,Array<Character>)
    {
      return isPalindrome(String(self))
    }
    

}






print(("Was it a car or a cat I saw").palindromeResult().1)
print(("Was it a car or a cat I saw").palindromeResult().0.description)
//"aetr".palindromeResult()
print(12445321.palindromeResult().1)
print(12445321.palindromeResult().0.description)





OutPut:

["a", "c", "i", "o", "r", "s", "t", "w"]
true
["1", "2", "3", "4", "5"]
false

